<?xml version="1.0"?>
<project name="elasticsearch-integration-tests"
         xmlns:if="ant:if">

  <!-- our pid file for easy cleanup -->
  <property name="integ.pidfile" location="${integ.scratch}/es.pid"/>

  <!-- if this exists, ES is running (maybe) -->
  <available property="integ.pidfile.exists" file="${integ.pidfile}"/>

  <!-- runs an OS script -->
  <macrodef name="run-script">
    <attribute name="script"/>
    <attribute name="spawn" default="false"/>
    <element name="nested" optional="true"/>
    <sequential>
      <local name="failonerror"/>
      <condition property="failonerror">
        <isfalse value="@{spawn}"/>
      </condition>

      <!-- create a temp CWD, to enforce that commands don't rely on CWD -->
      <local name="temp.cwd"/>
      <tempfile property="temp.cwd" destDir="${integ.temp}"/>
      <mkdir dir="${temp.cwd}"/>

      <!-- print commands we run -->
      <local name="script.base"/>
      <basename file="@{script}" property="script.base"/>
      <!-- crappy way to output, but we need it. make it nice later -->
      <echoxml>
        <exec script="${script.base}">
          <nested/>
        </exec>
      </echoxml>

      <exec executable="sh" osfamily="unix" dir="${temp.cwd}" failonerror="${failonerror}" spawn="@{spawn}"
            taskname="${script.base}">
        <arg value="@{script}"/>
        <nested/>
      </exec>
    </sequential>
  </macrodef>

  <!-- extracts PID from file -->
  <macrodef name="extract-pid">
    <attribute name="file"/>
    <attribute name="property"/>
    <sequential>
      <loadfile srcFile="@{file}" property="@{property}">
        <filterchain>
          <striplinebreaks/>
        </filterchain>
      </loadfile>
    </sequential>
  </macrodef>

  <!-- applies transformations to src and stores in dst -->
  <macrodef name="filter-property">
    <attribute name="src"/>
    <attribute name="dest"/>
    <element name="chain"/>
    <sequential>
      <loadresource property="@{dest}">
        <propertyresource name="@{src}"/>
        <filterchain>
          <tokenfilter>
            <chain/>
          </tokenfilter>
        </filterchain>
      </loadresource>
    </sequential>
  </macrodef>

  <!-- installs a plugin into elasticsearch -->
  <macrodef name="install-plugin">
    <attribute name="home" default="${integ.scratch}/elasticsearch-${elasticsearch.version}"/>
    <attribute name="name"/>
    <attribute name="file"/>
    <sequential>
      <local name="url"/>
      <makeurl property="url" file="@{file}"/>
      <!-- install plugin -->
      <echo>Installing plugin @{name}...</echo>
      <run-script script="@{home}/bin/plugin">
        <nested>
          <arg value="install"/>
          <arg value="${url}"/>
        </nested>
      </run-script>

      <fail message="did not find plugin installed as @{name}">
        <condition>
          <not>
            <resourceexists>
              <file file="@{home}/plugins/@{name}"/>
            </resourceexists>
          </not>
        </condition>
      </fail>
    </sequential>
  </macrodef>

  <!-- installs a module into elasticsearch -->
  <macrodef name="install-module">
    <attribute name="home" default="${integ.scratch}/elasticsearch-${elasticsearch.version}"/>
    <attribute name="name"/>
    <attribute name="file"/>
    <sequential>
      <!-- install module -->
      <echo>Installing module @{name}...</echo>
      <mkdir dir="@{home}/modules/@{name}"/>
      <unzip src="@{file}" dest="@{home}/modules/@{name}"/>

      <fail message="did not find module installed as @{name}">
        <condition>
          <not>
            <resourceexists>
              <file file="@{home}/modules/@{name}/plugin-descriptor.properties"/>
            </resourceexists>
          </not>
        </condition>
      </fail>
    </sequential>
  </macrodef>

  <!-- waits for elasticsearch to start -->
  <macrodef name="waitfor-elasticsearch">
    <attribute name="port"/>
    <attribute name="timeoutproperty"/>
    <sequential>
      <echo>Waiting for elasticsearch to become available on port @{port}...</echo>
      <waitfor maxwait="30" maxwaitunit="second"
               checkevery="500" checkeveryunit="millisecond"
               timeoutproperty="@{timeoutproperty}">
        <http url="http://localhost:@{port}"/>
      </waitfor>
    </sequential>
  </macrodef>

  <!-- waits for cluster to form and have exactly two nodes -->
  <macrodef name="waitfor-two-nodes">
    <attribute name="port"/>
    <attribute name="timeoutproperty"/>
    <sequential>
      <echo>Waiting for elasticsearch to form a cluster of two...</echo>
      <waitfor maxwait="30" maxwaitunit="second"
               checkevery="500" checkeveryunit="millisecond"
               timeoutproperty="@{timeoutproperty}">
        <http url="http://localhost:@{port}/_cluster/health?wait_for_nodes=2"/>
      </waitfor>
    </sequential>
  </macrodef>

  <!-- start elasticsearch and wait until its ready -->
  <macrodef name="startup-elasticsearch">
    <attribute name="home" default="${integ.scratch}/elasticsearch-${elasticsearch.version}"/>
    <attribute name="spawn" default="true"/>
    <attribute name="args" default="${integ.args}"/>
    <attribute name="es.unicast.hosts" default="localhost:${integ.transport.port}"/>
    <attribute name="es.cluster.name" default="${integ.cluster.name}"/>
    <attribute name="es.http.port" default="${integ.http.port}"/>
    <attribute name="es.java.port" default="${integ.java.port}"/>
    <attribute name="es.transport.tcp.port" default="${integ.transport.port}"/>
    <attribute name="es.pidfile" default="${integ.pidfile}"/>
    <attribute name="jvm.args" default="${tests.jvm.argline}"/>
    <element name="additional-args" optional="true"/>
    <sequential>
      <!-- make sure no elasticsearch instance is currently running and listening on the port we need -->
      <fail message="This test expects port @{es.http.port} to be free but an elasticsearch instance is already running and listening on that port.
      Maybe the last test run did not manage to shut down the node correctly?
      You must kill it before tests can run.">
        <condition>
          <socket server="localhost" port="@{es.http.port}"></socket>
        </condition>
      </fail>
      <!-- run bin/elasticsearch with args -->
      <echo>Starting up external cluster @{home}/bin/elasticsearch...</echo>
      <chmod file="@{home}/bin/elasticsearch" perm="o+x"/>
      <run-script script="@{home}/bin/elasticsearch"
                  spawn="@{spawn}"
                  >

        <nested>
          <arg value="-Epidfile=@{es.pidfile}" />
          <arg value="-Ecluster.name=@{es.cluster.name}"/>
          <arg value="-Ehttp.port=@{es.http.port}"/>
          <arg value="-Etransport.tcp.port=@{es.java.port}" />
          <additional-args/>
        </nested>
      </run-script>

      <!-- wait for startup -->
      <local name="failed.to.start"/>
      <waitfor-elasticsearch port="@{es.http.port}"
                             timeoutproperty="failed.to.start"/>

      <!-- best effort, print console log. useful if it fails especially -->
      <local name="log.contents"/>
      <loadfile srcFile="@{home}/logs/@{es.cluster.name}.log"
                property="log.contents"
                failonerror="false"/>
      <echo message="${log.contents}" taskname="elasticsearch"/>

      <fail message="ES instance did not start" if="failed.to.start"/>

      <local name="integ.pid"/>
      <extract-pid file="@{es.pidfile}" property="integ.pid"/>
      <echo>External node started PID ${integ.pid}</echo>
    </sequential>
  </macrodef>

  <!-- Takes a plugin zip file and return the plugin name. For instance
       'analysis-icu-2.0.0.zip' would return
       'analysis-icu'. -->
  <macrodef name="convert-plugin-name">
    <attribute name="file"/>
    <attribute name="outputproperty"/>
    <sequential>
      <local name="file.base"/>
      <basename file="@{file}" property="file.base"/>
      <filter-property src="file.base" dest="@{outputproperty}">
        <chain>
          <replacestring from="-${elasticsearch.version}.zip" to=""/>
        </chain>
      </filter-property>
    </sequential>
  </macrodef>

  <macrodef name="stop-node">
    <attribute name="es.pidfile" default="${integ.pidfile}"/>
    <sequential>
      <local name="integ.pid"/>

      <extract-pid file="@{es.pidfile}" property="integ.pid"/>
      <echo>Shutting down external node PID ${integ.pid}</echo>
      <!-- verify with jps that this actually is the correct pid.
      See if we can find the line "pid org.elasticsearch.bootstrap.Elasticsearch" in the output of jps -l.-->
      <local name="jps.pidline"/>
      <local name="jps.executable"/>
      <local name="environment"/>
      <property environment="environment"/>
      <property name="jps.executable" location="${environment.JAVA_HOME}/bin/jps"/>
      <exec executable="${jps.executable}" failonerror="true">
        <arg value="-l"/>
        <redirector outputproperty="jps.pidline">
          <outputfilterchain>
            <linecontains>
              <contains value="${integ.pid} org.elasticsearch.bootstrap.Elasticsearch"/>
            </linecontains>
          </outputfilterchain>
        </redirector>
      </exec>
      <fail
        message="pid file at @{es.pidfile} is ${integ.pid} but jps -l did not report any process with org.elasticsearch.bootstrap.Elasticsearch and this pid.
          Did you run mvn clean? Maybe an old pid file is still lying around.">
        <condition>
          <equals arg1="${jps.pidline}" arg2=""/>
        </condition>
      </fail>

      <exec executable="taskkill" failonerror="true" osfamily="winnt">
        <arg value="/F"/>
        <arg value="/PID"/>
        <arg value="${integ.pid}"/>
      </exec>
      <exec executable="kill" failonerror="true" osfamily="unix">
        <arg value="-9"/>
        <arg value="${integ.pid}"/>
      </exec>
      <delete file="@{es.pidfile}"/>
    </sequential>
  </macrodef>

  <!-- starts a unicast node on an already setup workspace-->
  <macrodef name="start-unicast-node">
    <attribute name="es.http.port" default="${integ.http.port}"/>
    <attribute name="es.transport.port" default="${integ.transport.port}"/>
    <attribute name="es.pidfile" default="${integ.pidfile}"/>
    <attribute name="es.peer.list"/>
    <sequential>
      <startup-elasticsearch es.pidfile="@{es.pidfile}"
                             es.transport.tcp.port="@{es.transport.port}" es.http.port="@{es.http.port}"
                             es.unicast.hosts="@{es.peer.list}"/>
    </sequential>
  </macrodef>

  <!-- unzip the elasticsearch zip -->
  <target name="setup-workspace" depends="stop-external-cluster">
    <sequential>
      <delete dir="${integ.scratch}"/>
      <unzip src="${integ.deps}/elasticsearch-${elasticsearch.version}.zip" dest="${integ.scratch}"/>
    </sequential>
  </target>

  <!-- run elasticsearch in the foreground (for debugging etc) -->
  <target name="start-foreground" depends="setup-workspace">
    <startup-elasticsearch
      spawn="false"
      jvm.args="${tests.jvm.argline} -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000"/>
  </target>


  <!-- unzip integ test artifact then start ES -->
  <target name="start-external-cluster" depends="setup-workspace">
    <startup-elasticsearch/>
  </target>

  <target name="stop-external-cluster" if="integ.pidfile.exists">
    <stop-node/>
    <condition property="tests.failed">
      <not>
        <resourcecontains resource="${project.build.directory}/failsafe-reports/failsafe-summary.xml"
                          substring="&lt;failures&gt;0&lt;/failures&gt;"/>
      </not>
    </condition>
    <antcall target="dump-cluster-log-if-failed"/>
  </target>

  <target name="file-checks">
  <!--  <available file="/home/doc/somefile" property="first.file.found"/>
    <available file="/usr/local/somefile" property="second.file.found"/>-->
  </target>

  <target name="dump-cluster-log-if-failed" if="tests.failed">
    <local name="log.contents"/>
    <loadfile srcFile="${integ.scratch}/elasticsearch-${elasticsearch.version}/logs/api-test.log"
              property="log.contents"/>
    <echo message="${log.contents}" taskname="elasticsearch"/>
  </target>

</project>
